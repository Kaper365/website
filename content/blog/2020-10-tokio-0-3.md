---
date: "2020-10-15"
title: "Announcing Tokio 0.3 and the path to 1.0"
description: "October 14, 2020"
---

The Tokio team is excited to announce the release of Tokio 0.3, which is our beta release towards Tokio 1.0. The release fixes rough edges in the API discovered by users using 0.2 and provides an opportunity for validating the changes before stabilizing them as part of 1.0. As most of these issues were small, we expect that upgrading from 0.2 to 0.3 will be easy.

## Plan for 1.0

The Tokio team plans to release Tokio 1.0 by the end of December 2020. This date is fast approaching. We ask that *you*, the Tokio community, try out Tokio 0.3 and give us feedback through [GitHub Issues](https://github.com/tokio-rs/tokio/issues) or our [Discord channel](https://discord.gg/tokio). Once we release Tokio 1.0, we will commit to the following stability guarantees:

1. A minimum of 5 years of maintenance.
2. A minimum of 3 years before a hypothetical 2.0 release.

## What’s new?

The main changes in Tokio 0.3 are:

1. Changes to IO traits.
2. New runtime builder.
3. The I/O driver is overhauled
4. The API is future proofed.

You can find the full list on the [changelog](TODO LINK).

## Changes to IO traits

Following the lead of @sfackler’s [RFC](https://github.com/rust-lang/rfcs/pull/2930), we changed the `AsyncRead` and `AsyncWrite` traits to support reading into uninitialized memory. This change *only* affects users who implement the `AsyncRead` or `AsyncWrite` traits or manually calling the `poll_*` methods. If the `AsyncReadExt` or `AsyncWriteExt` traits are used, no change is required.

Below is a simplified version of the new `AsyncRead`:

```rust
pub trait AsyncRead {
    fn poll_read(
        self: Pin<&mut Self>, 
        cx: &mut Context<'_>, 
        buf: &mut ReadBuf<'_>
    ) -> Poll<Result<()>>;
}

pub struct ReadBuf<'a> {
    buf: &'a mut [MaybeUninit<u8>],
    filled: usize,
    initialized: usize,
}

impl<'a> ReadBuf<'a> {
    // functions here, see RFC
}
```
The `&mut [u8]` argument to the Tokio 0.2’s `poll_read` method has some unintended sharp edges: an implementer, not the end consumer, of the `AsyncRead` trait can *read* the data stored in the `&mut [u8]` slice. If a programmer creates a mutable slice of bytes (a `&mut [u8]`) that references uninitialized memory (e.g., the excess capacity in a vector), then *reading* the `&mut [u8]` data would cause undefined behavior. The new design mitigates this issue by providing a `ReadBuf` struct that tracks the uninitialized memory, removing the need to initialize memory.

Additionally, the `poll_read_buf` and `poll_write_buf` methods have been removed from both traits. In practice, these methods were rarely implemented. Vectored operations will be implemented by types that support them.

## Feature flag simplification

We have reduced the amount of feature flags needed to use the core features of Tokio. The `dns`, `tcp`, `udp`,  and `uds` feature flags are collapsed into a single `net` feature flag. We have also combined `rt-core` and `rt-util` into a single `rt` feature flag. This `rt` feature flag now encompasses everything to execute futures except for the multi-threaded runtime which now lives under a `rt-multi-thread` feature flag (previously was called `rt-threaded`).

- `dns`, tcp`, `udp` and `uds` -> `net`
- `rt-util` and `rt-core` -> `rt`
- `rt-threaded` -> `rt-multi-threaded`

## Runtime and Builder refactor

The Tokio team has removed  `threaded_scheduler` and `basic_scheduler` from the public API. Instead, the runtime `Builder` type introduces two constructors: one constructor for a multi-threaded scheduler and one for a current thread scheduler. These constructors provide a misuse-resistant form of building a runtime that *does not* require fiddling with feature flags and builder methods. Tokio will no longer choose the runtime variant based on feature flags when using `Runtime::new` but instead will default to the multi-threaded runtime and is only available under the `rt` feature flag. In addition, we’ve renamed the `core_threads` builder method to the more accurate `worker_threads`. 

We have also refactored the runtime module. Tokio 0.2 exposed two types to interact with the Tokio runtime: `Runtime` and `Handle`. `Runtime` has a `block_on` method that required `&mut self`, whereas `Handle` has a `block_on` method that required `&self`. With Tokio 0.3, we collapsed `Runtime` and `Handle` into a single `Runtime`. Tokio 0.3’s `Runtime`‘s `block_on` now accepts `&self`, which supports concurrent calls to `block_on`. This also means `Runtime` implements `Send` and `Sync` and can therefore be stored in an `Arc`.

An example configuring a multi-threaded runtime with 6 worker threads:

```rust
use tokio::runtime::Builder;

let rt = Builder::new_multi_thread()
    .worker_threads(6)
    .enable_all()
    .build()
    .unwrap();

rt.block_on(async {
    println!("Hello world!");
});
```

## Methods changed to `&self`

We have updated our io types to use an intrusive linked list for storing the wakers. This has allowed us to change many of the methods on types like `TcpStream` and `UdpSocket` to merely take `&self`. This makes it easier to work with our io types across tasks.

## Removal of non-1.0 crates from the public API

In our push for 1.0 we have removed many non-1.0 dependencies from the public API. This includes `bytes` and `mio`. This will allow us to push for a simpler and more stable 1.0 while we continue to innovate in our low-level crates.

## Mio 0.7

We have finally also upgraded `mio` to 0.7 which was originally released in an alpha in December of 2019 and did not make the cut for Tokio 0.2. Since then `mio` 0.7 has had time to mature and is finally making it into this release of Tokio 0.3. This upgrades some key dependencies like `winapi` from 0.2 to 0.3.

## Compat between 0.2 and 0.3

It is possible to upgrade to Tokio 0.3 incrementally via using the `context` module in `tokio_util`. Below is an example of how you can jump start this transition:

*Note: this will spawn two runtimes one main multi-threaded runtime using the 0.3 scheduler and a single threaded 0.2 runtime running on a background thread.*

```rust
// Let's create a Tokio 0.2 runtime using the old builder. This will create a multi-threaded runtime running on a single thread.
let rt_02 = tokio_02::runtime::Builder::new()
    .threaded_scheduler()
    .enable_all()
    .core_threads(1)
    .build()
    .unwrap();

// This will create a multi-threaded runtime to be the main executor.
let rt_03 = tokio_03::runtime::Runtime::new().unwrap();

struct Runtime {
    rt_03: tokio_03::runtime::Runtime,
    rt_02: tokio_02::runtime::Runtime,
}

impl Runtime {
    fn block_on<F: Future>(&self, f: F) -> F::Output {
        let fut = self.rt_02.wrap(f);
        self.rt_03.block_on(fut)
    }

    fn spawn<F: Future + Send + 'static>(&self, f: F) {
        let fut = self.rt_02.wrap(f);
        self.rt_03.spawn(fut);
    }
}
```

This example now provides the ability to `block_on` and `spawn` futures that have the runtime context from Tokio 0.2 and 0.3.

## Conclusion

We've had over 50 contributors help us out since the release of Tokio 0.2. We can't thank our community enough for helping us find bugs and fixing them. As we continue to move towards 1.0 feedback will be more critical than ever, so please feel free to open issues or join us on [Discord](https://discord.gg/tokio) to help us get there.
